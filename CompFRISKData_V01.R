##################################################################################################################
## Project: Compare FRISK data files for ERC stream testing
##
## Script purpose: Compare Remap fire risk files generated by Fire Family plus software fose base case climate
##                 between USFS starting data and risQ pyrome averaged data 
##
## Date: 19th March 2020
## Author: JR
##################################################################################################################

# Required testing many libraries. Be selective in initializing libraries
library(rlang) 
library(maptools) 
library(GISTools) 
library(plyr)
library(dplyr)
library(lwgeom)
library(sf)
library(sp)
library(gdalUtils)
library(stringr)
library(smoothr)
library(units)
library(geosphere)
library(fields)
library(rasterVis) 
library(OpenImageR)
library(gdalUtils)
library(SDMTools)
library(truncnorm)
library(ggplot2)
library(rgdal)
library(raster) 
library(rgeos)
library(lubridate)
library(stringi)
library(splitstackshape)
library(data.table)
library(tidyverse)
library(hrbrthemes)
library(viridis)

# Projection string for meter projection US wide
AEAProj <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-110
+x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m'

# Sheffs preferred output projections
laea_proj4 <- "+proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"

# Test for valid GDAL install
gdal_setInstallation()
valid_install <- !is.null(getOption("gdalUtils_gdalPath"))
if(require(raster) && require(rgdal) && valid_install)
{
  print('TRUE')
}
#gdal_setInstallation(ignore.full_scan=FALSE)

# Set raster options
rasterOptions(maxmemory = 5.0e+09)

#if("package:adehabitatHR" %in% search()) detach("package:adehabitatHR", unload=TRUE)

memory.limit()
# set max memory usage 
memory.size(max=5.0e+09)

##################################################################################################################
## Section: Set global directory locations
##################################################################################################################

# Get the data directory from readtext
ROOT_DATA_DIR <- 'C:/ERCTimeSeriesAnalysis'
DATA_DIR <- ('Data') 
OUTPUT_DIR <- ('Output') 
DATA_YR <- 1819
DATA_YR_OUT <- 2019

# specify working directory; you will need to change this line if run elsewhere
setwd(ROOT_DATA_DIR)

# Check directory
getwd()
wd <- getwd()
print(paste0('Current working dir: ', wd))

# Temporary raster location
raster::rasterOptions(tmpdir = wd)

# Specify output folder suffix
VersonOut <- 3

##################################################################################################################
## Section: Read FRISK files and compare
##################################################################################################################

# Read concatenated data.table of all pyromes combined - list of data.frames
cmbndstnrdatfile <- paste0(ROOT_DATA_DIR,'/',OUTPUT_DIR,'/AvgdCombdStationNARR.rds')
wthrdatallpyrs.DT <- readRDS(cmbndstnrdatfile) 

# Total number of pyromes
numpyr <- 128
pyromes <- seq(1,numpyr,1)

# Select subset of pyromes
pyrssub <- sprintf('%03d',seq(1:128))

# Set test selection
pyromes <- c(1,8,20,26,45,46,75,88,101,118,122,127)
pyromes <- c(8)
pyrssub <- sprintf('%03d',pyromes)

# Set type of comparison
BASE <- FALSE

# Loop through pyromes 
for (ipyr in 1:length(pyromes)) { 
  
  # Evaluate pyrome code
  PYROMEIN <- sprintf("%03d", as.integer(pyromes[ipyr]))
  idx_one_in_two <- match(PYROMEIN, unlist(pyrssub))
  
  # Select subset of pyromes
  if (!is.na(idx_one_in_two)) { 
    
    cat('Current Pyrome ', PYROMEIN)
    
    ################################################### READ AVERAGED/AUGMENTED STATION FILE
    # Read averaged modeled station data by pyrome
    pyrnms <- names(wthrdatallpyrs.DT)
    pyrmin <- substring(pyrnms[as.integer(pyrssub[ipyr])],8,10)
    pyrmin <- as.integer(pyrmin)
    PYROMEIN <- sprintf("%03d", as.integer(pyrmin))
    
    # Create data.table for current pyrome data 
    wthrdat.dt <- as.data.table(wthrdatallpyrs.DT[[pyrmin]])
    
    # Rename odd field names
    setnames(wthrdat.dt, 'ATMOIST', 'RH')
    setnames(wthrdat.dt, 'RAIN', 'Rain')
    
    # Split date field into Year, month and day fields
    wthrdat.dt[, YEAR := as.numeric(format(DATE, format = "%Y"))] 
    wthrdat.dt[, YEAR := sprintf("%04d", as.integer(YEAR))]   
    wthrdat.dt[, MONTH := sprintf("%02d", as.integer(month(DATE)))]
    wthrdat.dt[, DAY := sprintf("%02d", as.integer(day(DATE)))]
    wthrdat.dt[, DAYOFYR := as.integer(yday(DATE))]
    ################################################### READ AVERAGED/AUGMENTED STATION FILE

    # Open files to compare
    outloc <- paste0('Version_V',sprintf("%02d", as.integer(VersonOut)),'/')
    filedir <- paste0(ROOT_DATA_DIR,'/',OUTPUT_DIR,'/',outloc,PYROMEIN) 
    
    if (BASE == FALSE) {
      risQfile <- paste0('P',PYROMEIN,'CCDWERCFSIMInput_92-19.txt')
      USFSfile <- paste0('PY_',PYROMEIN,'.txt')
      STTNfile <- paste0('P',PYROMEIN,'CCDWERCFSIMInput_92-19.txt') 
      NARRfile <- paste0('P',PYROMEIN,'CCDWERCFSIMInput_92-19.txt') 
      flag <- 'CCDW'
    } else {
      risQfile <- paste0('P',PYROMEIN,'BaseERCFSIMInput_92-19.txt') 
      USFSfile <- paste0('PY_',PYROMEIN,'.txt')
      STTNfile <- paste0('P',PYROMEIN,'BaseERCFSIMInput_92-19.txt') 
      NARRfile <- paste0('P',PYROMEIN,'BaseERCFSIMInput_92-19.txt')   
      flag <- 'BASE'
    }
    
    if (!dir.exists(filedir)){
      dir.create(filedir,recursive = TRUE)
    } else {
      print("Dir already exists!")
    }
     
    ################################################### READ RISQ FILE
    # Read data to data.table line by line
    risQfile <- paste0(filedir,'/',risQfile)  
    risQ.DT <- fread(risQfile,  skip = 30L, colClasses = "character",strip.white = FALSE,
                        sep = "\t", nrows = 365, header = FALSE, verbose = TRUE)
    setnames(risQ.DT, old = 1:4, new = c('ERC_AVG','ERC_STDDEV','ERC_CURR','DATE'))
    lengthdt <- ncol(risQ.DT) - 4
    newnms <- paste0('ERCYR_',1:lengthdt)
    setnames(risQ.DT, old = 5:ncol(risQ.DT), new = newnms)
    
    # Enforce to be numeric
    convrttype <- names(risQ.DT)
    convrttype <- convrttype[-which(convrttype == 'DATE')]
    mtimes <- rep(c('numeric'),each=length(convrttype))
    mtimes <- setNames(mtimes, convrttype)
    set_colclass(risQ.DT,mtimes)

    # Reformat date column
    risQ.DT[, paste0('DATE', 1:3) := tstrsplit(DATE, '(/)', perl = TRUE)][]
    timecols <- c('DATE3', 'DATE1','DATE2') #c('YEAR', 'MONTH','DAY')
    risQ.DT[, DATE3 := as.numeric(format(DATE3, format = "%Y"))] 
    risQ.DT[, DATE1 := sprintf("%02d", as.integer(DATE1))]
    risQ.DT[, DATE2 := sprintf("%02d", as.integer(DATE2))]
    risQ.DT[, CORDATE := do.call(paste, c(.SD, sep = '-')), .SDcols = timecols]
    risQ.DT[, CORDATE := parse_date_time(paste0(CORDATE), 'Ymd')]
    risQ.DT[ ,`:=`(DATE3 = NULL, DATE1 = NULL, DATE2 = NULL, DATE = NULL)]
    setnames(risQ.DT, 'CORDATE', 'DATE')
    risQ.DT[, DAYOFYR := as.integer(yday(DATE))]
    
    # Remove leap year days - Appears no leap year in data!
    risQ.DT[, MONTH := sprintf("%02d", as.integer(month(DATE)))]
    risQ.DT[, DAY := sprintf("%02d", as.integer(day(DATE)))]    
    risQ.DT <- subset(risQ.DT, !(DAY == '29' & MONTH == '02'))
    risQ.DT[, YEAR := as.numeric(format(DATE, format = "%Y"))] 
    risQ.DT[, DAYOFYR := DAYOFYR][(DAYOFYR > 60) & is.leapyear(YEAR) == TRUE, DAYOFYR := DAYOFYR - 1][]
    risQ.DT[ ,`:=`(DAY = NULL, MONTH = NULL, YEAR = NULL)]     
    
    # Format final columns     
    yearin <- unique(risQ.DT[ , list(YEAR = year(DATE))])
    yearin <- unlist(yearin) 
    yrstrt <- yearin - ncol(risQ.DT) + 5
    yrends <- yearin - 1
    newnms <- paste0('ERCYR_',yrstrt:yrends)
    lastcol <- ncol(risQ.DT) - 2
    setnames(risQ.DT, old = 4:lastcol, new = newnms)
    setnames(risQ.DT, 'ERC_CURR', paste0('ERCYR_',yearin))
    risQ.DT[ ,`:=`(ERC_AVG = NULL, ERC_STDDEV = NULL, DATE = NULL)]
    risQ.DT <- Stacked(risQ.DT, 'DAYOFYR', c('ERCYR'), "_")
    #setnames(risQ.DT, 'ERCYR', 'ERCYR_RISQ') 
    setnames(risQ.DT, '.time_1', 'YEAR') 
    
    # Calculate span of years for USFS data
    minyrrisq <- min(risQ.DT[, YEAR])
    maxyrrisq <- max(risQ.DT[, YEAR])
    ################################################### READ RISQ FILE
    
    ################################################### READ USFS FILE
    # Read data to data.table line by line
    USFSfile <- paste0(filedir,'/',USFSfile)  
    usfs.DT <- fread(USFSfile,  skip = 4L, colClasses = "character",strip.white = FALSE,
                     sep = "\t", nrows = 365, header = FALSE, verbose = TRUE)
    setnames(usfs.DT, old = 1:4, new = c('ERC_AVG','ERC_STDDEV','ERC_CURR','DATE'))
    lengthdt <- ncol(usfs.DT) - 4
    newnms <- paste0('ERCYR_',1:lengthdt)
    setnames(usfs.DT, old = 5:ncol(usfs.DT), new = newnms)
    
    # Enforce to be numeric
    convrttype <- names(usfs.DT)
    convrttype <- convrttype[-which(convrttype == 'DATE')]
    mtimes <- rep(c('numeric'),each=length(convrttype))
    mtimes <- setNames(mtimes, convrttype)
    set_colclass(usfs.DT,mtimes)
    
    # Reformat date column
    usfs.DT[, paste0('DATE', 1:3) := tstrsplit(DATE, '(/)', perl = TRUE)][]
    timecols <- c('DATE3', 'DATE1','DATE2') #c('YEAR', 'MONTH','DAY')
    usfs.DT[, DATE3 := as.numeric(format(DATE3, format = "%Y"))] 
    usfs.DT[, DATE1 := sprintf("%02d", as.integer(DATE1))]
    usfs.DT[, DATE2 := sprintf("%02d", as.integer(DATE2))]
    usfs.DT[, CORDATE := do.call(paste, c(.SD, sep = '-')), .SDcols = timecols]
    usfs.DT[, CORDATE := parse_date_time(paste0(CORDATE), 'Ymd')]
    usfs.DT[ ,`:=`(DATE3 = NULL, DATE1 = NULL, DATE2 = NULL, DATE = NULL)]
    setnames(usfs.DT, 'CORDATE', 'DATE')
    usfs.DT[, DAYOFYR := as.integer(yday(DATE))]
    
    # Remove leap year days - Appears no leap year in data!
    usfs.DT[, MONTH := sprintf("%02d", as.integer(month(DATE)))]
    usfs.DT[, DAY := sprintf("%02d", as.integer(day(DATE)))]    
    usfs.DT <- subset(usfs.DT, !(DAY == '29' & MONTH == '02'))
    usfs.DT[, YEAR := as.numeric(format(DATE, format = "%Y"))] 
    usfs.DT[, DAYOFYR := DAYOFYR][(DAYOFYR > 60) & is.leapyear(YEAR) == TRUE, DAYOFYR := DAYOFYR - 1][]
    usfs.DT[ ,`:=`(DAY = NULL, MONTH = NULL, YEAR = NULL)]     
    
    # Format final columns 
    yearin <- unique(usfs.DT[ , list(YEAR = year(DATE))])
    yearin <- unlist(yearin) 
    yrstrt <- yearin - ncol(usfs.DT) + 5
    yrends <- yearin - 1
    newnms <- paste0('ERCYR_',yrstrt:yrends)
    lastcol <- ncol(usfs.DT) - 2
    setnames(usfs.DT, old = 4:lastcol, new = newnms)
    setnames(usfs.DT, 'ERC_CURR', paste0('ERCYR_',yearin))
    usfs.DT[ ,`:=`(ERC_AVG = NULL, ERC_STDDEV = NULL, DATE = NULL)]
    usfs.DT <- Stacked(usfs.DT, 'DAYOFYR', c('ERCYR'), "_")
    #setnames(usfs.DT, 'ERCYR', 'ERCYR_USFS')  
    setnames(usfs.DT, '.time_1', 'YEAR')
    
    # Calculate span of years for USFS data
    minyrUSFS <- min(usfs.DT[, YEAR])
    maxyrUSFS <- max(usfs.DT[, YEAR])
    ################################################### READ USFS FILE
    
    ################################################### READ STTN FILE
    # Read data to data.table line by line
    STTNfile <- paste0(filedir,'/',STTNfile)  
    STTN.DT <- fread(STTNfile,  skip = 4L, colClasses = "character",strip.white = FALSE,
                     sep = "\t", nrows = 365, header = FALSE, verbose = TRUE)
    setnames(STTN.DT, old = 1:4, new = c('ERC_AVG','ERC_STDDEV','ERC_CURR','DATE'))
    lengthdt <- ncol(STTN.DT) - 4
    newnms <- paste0('ERCYR_',1:lengthdt)
    setnames(STTN.DT, old = 5:ncol(STTN.DT), new = newnms)
    
    # Enforce to be numeric
    convrttype <- names(STTN.DT)
    convrttype <- convrttype[-which(convrttype == 'DATE')]
    mtimes <- rep(c('numeric'),each=length(convrttype))
    mtimes <- setNames(mtimes, convrttype)
    set_colclass(STTN.DT,mtimes)
    
    # Reformat date column
    STTN.DT[, paste0('DATE', 1:3) := tstrsplit(DATE, '(/)', perl = TRUE)][]
    timecols <- c('DATE3', 'DATE1','DATE2') #c('YEAR', 'MONTH','DAY')
    STTN.DT[, DATE3 := as.numeric(format(DATE3, format = "%Y"))] 
    STTN.DT[, DATE1 := sprintf("%02d", as.integer(DATE1))]
    STTN.DT[, DATE2 := sprintf("%02d", as.integer(DATE2))]
    STTN.DT[, CORDATE := do.call(paste, c(.SD, sep = '-')), .SDcols = timecols]
    STTN.DT[, CORDATE := parse_date_time(paste0(CORDATE), 'Ymd')]
    STTN.DT[ ,`:=`(DATE3 = NULL, DATE1 = NULL, DATE2 = NULL, DATE = NULL)]
    setnames(STTN.DT, 'CORDATE', 'DATE')
    STTN.DT[, DAYOFYR := as.integer(yday(DATE))]
    
    # Remove leap year days - Appears no leap year in data!
    STTN.DT[, MONTH := sprintf("%02d", as.integer(month(DATE)))]
    STTN.DT[, DAY := sprintf("%02d", as.integer(day(DATE)))]    
    STTN.DT <- subset(STTN.DT, !(DAY == '29' & MONTH == '02'))
    STTN.DT[, YEAR := as.numeric(format(DATE, format = "%Y"))] 
    STTN.DT[, DAYOFYR := DAYOFYR][(DAYOFYR > 60) & is.leapyear(YEAR) == TRUE, DAYOFYR := DAYOFYR - 1][]
    STTN.DT[ ,`:=`(DAY = NULL, MONTH = NULL, YEAR = NULL)]     
    
    # Format final columns 
    yearin <- unique(STTN.DT[ , list(YEAR = year(DATE))])
    yearin <- unlist(yearin) 
    yrstrt <- yearin - ncol(STTN.DT) + 5
    yrends <- yearin - 1
    newnms <- paste0('ERCYR_',yrstrt:yrends)
    lastcol <- ncol(STTN.DT) - 2
    setnames(STTN.DT, old = 4:lastcol, new = newnms)
    setnames(STTN.DT, 'ERC_CURR', paste0('ERCYR_',yearin))
    STTN.DT[ ,`:=`(ERC_AVG = NULL, ERC_STDDEV = NULL, DATE = NULL)]
    STTN.DT <- Stacked(STTN.DT, 'DAYOFYR', c('ERCYR'), "_")
    #setnames(usfs.DT, 'ERCYR', 'ERCYR_USFS')  
    setnames(STTN.DT, '.time_1', 'YEAR')
    
    # Calculate span of years for USFS data
    minyrSTTN <- min(STTN.DT[, YEAR])
    maxyrSTTN <- max(STTN.DT[, YEAR])
    ################################################### READ STTN FILE
    
    ################################################### READ NARR FILE
    # Read data to data.table line by line
    NARRfile <- paste0(filedir,'/',NARRfile)  
    NARR.DT <- fread(NARRfile,  skip = 4L, colClasses = "character",strip.white = FALSE,
                     sep = "\t", nrows = 365, header = FALSE, verbose = TRUE)
    setnames(NARR.DT, old = 1:4, new = c('ERC_AVG','ERC_STDDEV','ERC_CURR','DATE'))
    lengthdt <- ncol(NARR.DT) - 4
    newnms <- paste0('ERCYR_',1:lengthdt)
    setnames(NARR.DT, old = 5:ncol(NARR.DT), new = newnms)
    
    # Enforce to be numeric
    convrttype <- names(NARR.DT)
    convrttype <- convrttype[-which(convrttype == 'DATE')]
    mtimes <- rep(c('numeric'),each=length(convrttype))
    mtimes <- setNames(mtimes, convrttype)
    set_colclass(NARR.DT,mtimes)
    
    # Reformat date column
    NARR.DT[, paste0('DATE', 1:3) := tstrsplit(DATE, '(/)', perl = TRUE)][]
    timecols <- c('DATE3', 'DATE1','DATE2') #c('YEAR', 'MONTH','DAY')
    NARR.DT[, DATE3 := as.numeric(format(DATE3, format = "%Y"))] 
    NARR.DT[, DATE1 := sprintf("%02d", as.integer(DATE1))]
    NARR.DT[, DATE2 := sprintf("%02d", as.integer(DATE2))]
    NARR.DT[, CORDATE := do.call(paste, c(.SD, sep = '-')), .SDcols = timecols]
    NARR.DT[, CORDATE := parse_date_time(paste0(CORDATE), 'Ymd')]
    NARR.DT[ ,`:=`(DATE3 = NULL, DATE1 = NULL, DATE2 = NULL, DATE = NULL)]
    setnames(NARR.DT, 'CORDATE', 'DATE')
    NARR.DT[, DAYOFYR := as.integer(yday(DATE))]
    
    # Remove leap year days - Appears no leap year in data!
    NARR.DT[, MONTH := sprintf("%02d", as.integer(month(DATE)))]
    NARR.DT[, DAY := sprintf("%02d", as.integer(day(DATE)))]    
    NARR.DT <- subset(NARR.DT, !(DAY == '29' & MONTH == '02'))
    NARR.DT[, YEAR := as.numeric(format(DATE, format = "%Y"))] 
    NARR.DT[, DAYOFYR := DAYOFYR][(DAYOFYR > 60) & is.leapyear(YEAR) == TRUE, DAYOFYR := DAYOFYR - 1][]
    NARR.DT[ ,`:=`(DAY = NULL, MONTH = NULL, YEAR = NULL)]     
    
    # Format final columns 
    yearin <- unique(NARR.DT[ , list(YEAR = year(DATE))])
    yearin <- unlist(yearin) 
    yrstrt <- yearin - ncol(NARR.DT) + 5
    yrends <- yearin - 1
    newnms <- paste0('ERCYR_',yrstrt:yrends)
    lastcol <- ncol(NARR.DT) - 2
    setnames(NARR.DT, old = 4:lastcol, new = newnms)
    setnames(NARR.DT, 'ERC_CURR', paste0('ERCYR_',yearin))
    NARR.DT[ ,`:=`(ERC_AVG = NULL, ERC_STDDEV = NULL, DATE = NULL)]
    NARR.DT <- Stacked(NARR.DT, 'DAYOFYR', c('ERCYR'), "_")
    #setnames(usfs.DT, 'ERCYR', 'ERCYR_USFS')  
    setnames(NARR.DT, '.time_1', 'YEAR')
    
    # Calculate span of years for USFS data
    minyrNARR <- min(NARR.DT[, YEAR])
    maxyrNARR <- max(NARR.DT[, YEAR])
    ################################################### READ NARR FILE

    # Append data.tables from each data source
    filesappend <- list(risQ.DT, usfs.DT, STTN.DT, NARR.DT) 
    setattr(filesappend, 'names', c('RISQ', 'USFS', 'STTN', 'NARR'))
    cnmd.dt.mt <- rbindlist(filesappend, use.names=TRUE, fill=TRUE, idcol='SRCE')
    
    # Get min and max date values for complete timeseries
    mindate <- min('1980-01-01')
    maxdate <- max('2019-12-31')  
    cont_date_time <- as.data.table(data.frame(seq(as.Date(mindate), as.Date(maxdate), 'days')))
    setnames(cont_date_time, 1, 'DATE')
    cont_date_time[,YEAR := as.character(year(DATE))]
    cont_date_time[,DAYOFYR := yday(DATE)]   

    # Append weather data from station averaging/augmentation
    setkey(cont_date_time, YEAR, DAYOFYR)
    setkey(risQ.DT, YEAR, DAYOFYR)     
    risq.dt.extd <- merge(risQ.DT,cont_date_time , all = TRUE)
    risq.dt.extd[,`:=`(YEAR = NULL, DAYOFYR = NULL)]
    setkey(wthrdat.dt, DATE)
    setkey(risq.dt.extd, DATE) 
    wthr.dt.augmtd <- merge(risq.dt.extd,wthrdat.dt , all = TRUE)

    # Write concatenated data.table
    outloc <- paste0('Version_V',sprintf("%02d", as.integer(VersonOut)),'/')
    filedir <- paste0(ROOT_DATA_DIR,'/',OUTPUT_DIR,'/',outloc,PYROMEIN) 
    fileout <- paste0(flag,'_AvgdStatDataCWERC_',PYROMEIN,'.rds')  
    if (!dir.exists(filedir)){
      dir.create(filedir,recursive = TRUE)
    } else {
      print("Dir already exists!")
    }
    fileout <- paste0(filedir,'/',fileout)
    saveRDS(wthr.dt.augmtd,fileout)

    # Combine data sets
    setkey(cnmd.dt.mt, YEAR, DAYOFYR)
    sapply(cnmd.dt.mt,class)
    setkey(cont_date_time, YEAR, DAYOFYR) 
    sapply(cont_date_time,class)
    cnmd.dt.extd <- merge(cnmd.dt.mt,cont_date_time , all = TRUE)
    
    drop_rows_all_na <- function(x, pct=0.01) x[!rowSums(is.na(x)) >= ncol(x)*pct,]
    cnmd.dt.extd <- drop_rows_all_na(cnmd.dt.extd,0.001)
    
    # Get min/max of years
    minyr <- max(minyrrisq,minyrUSFS,minyrSTTN,minyrNARR)
    maxyr <- min(maxyrrisq,maxyrUSFS,maxyrSTTN,maxyrNARR)
    
    # Fix errors in input files
    is.na(cnmd.dt.extd) <- sapply(cnmd.dt.extd, is.nan)
    cnmd.dt.extd <- cnmd.dt.extd[SRCE != 0]
    #cnmd.dt.extd <- cnmd.dt.extd[, YEAR := YEAR][YEAR<=maxyr & YEAR>=minyr] 
    cnmd.dt.extd <- cnmd.dt.extd[ERCYR != -9999.0]
    
    # Create statistics by day of year and pyrome
    #cnmd.dt.extd <- cnmd.dt.extd[, YEAR := YEAR][YEAR<=2013 & YEAR>=1992]   
    cnmd.dt.extd.stats <- cnmd.dt.extd[,list(NUMOFYRS = .N,NUMOFDAYS = .N,
                                             SRCEmean=mean(ERCYR, na.rm=TRUE),
                                             SRCEsd=sd(ERCYR, na.rm=TRUE),                                      
                                             SRCEmin=min(ERCYR, na.rm=TRUE),
                                             SRCEmedian = median(ERCYR, na.rm=TRUE),
                                             SRCEQ80=quantile(ERCYR, .80, na.rm=TRUE),
                                             SRCEQ90=quantile(ERCYR, .90, na.rm=TRUE),
                                             SRCEQ97=quantile(ERCYR, .97, na.rm=TRUE),
                                             SRCEmax=max(ERCYR)),by=c('SRCE','DAYOFYR')]
    setorder(cnmd.dt.extd.stats, SRCE, DAYOFYR)
    
    BASEQnts <- (cnmd.dt.extd[, .(Q80=quantile(ERCYR, .80, na.rm=TRUE),
                                  Q90=quantile(ERCYR, .90, na.rm=TRUE),
                                  Q97=quantile(ERCYR, .97, na.rm=TRUE)),by=c('SRCE')])
    
    # Evaluate labels
    Date <- seq(as.Date("1981/1/1"), as.Date("1981/12/31"), "day")
    cnmd.dt.extd.dt <- unique(cnmd.dt.extd, by = 'DAYOFYR')
    seltvar <- c('DAYOFYR')
    cnmd.dt.extd.dt <- cnmd.dt.extd.dt[, ..seltvar]
    cnmd.dt.extd.DF <- setDF(cnmd.dt.extd.dt)
    cnmd.dt.extd.DF <- cbind(cnmd.dt.extd.DF,Date)
    cnmd.dt.extd.DF$MonthDay <- format(cnmd.dt.extd.DF$Date, "%d-%b")
    
    # Only show every Xth label... otherwise it's too crowded
    cnmd.dt.extd.DF$MonthDay[as.numeric(row.names(cnmd.dt.extd.DF))%%7!=0] <- ""
    labelsin <- cnmd.dt.extd.DF$MonthDay

    perc80RISQ <- BASEQnts[SRCE == 'RISQ'][,Q80]
    perc80USFS <- BASEQnts[SRCE == 'USFS'][,Q80]
    perc90RISQ <- BASEQnts[SRCE == 'RISQ'][,Q90]
    perc90USFS <- BASEQnts[SRCE == 'USFS'][,Q90]    
    perc97RISQ <- BASEQnts[SRCE == 'RISQ'][,Q97]
    perc97USFS <- BASEQnts[SRCE == 'USFS'][,Q97]
    
    # Create output directory if required
    outpdir <- paste0('PYR',PYROMEIN) 
    outputDIR <- file.path(paste0(ROOT_DATA_DIR,'/',OUTPUT_DIR,'/Plots/',outpdir,'/Mean'))
    if (!dir.exists(outputDIR)) {dir.create(outputDIR,recursive = TRUE)}
    setwd(outputDIR)
    
    # Plot ggplot - MEAN per day
    setDF(cnmd.dt.extd.stats)
    legend_title <- 'Source Type'
    p <- ggplot() + geom_line(data=cnmd.dt.extd.stats, aes(x=factor(DAYOFYR), y=SRCEmean, group = factor(SRCE)
                                                           , colour = factor(SRCE)), size=1) + 
      theme(legend.position = c(0.9, 0.8)) + 
      scale_color_discrete(name = legend_title) +
      scale_x_discrete(labels=labelsin) + 
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 8)) +
      scale_y_continuous(breaks = pretty(cnmd.dt.extd.stats$SRCEmean, n = 10)) +
      geom_hline(yintercept = perc80RISQ, colour = 'Red') + 
      geom_hline(yintercept = perc80USFS, colour = 'Turquoise')  +    
      labs(title = paste0(flag,' Pyrome ',PYROMEIN,' - FFSIM FRISK file inputs comparison'),
           subtitle = ('Mean ERC by Day of Year'),
           x = 'Day of Year',
           y = 'ERC') + labs(caption = 'USFS/risQ Climate Conditioning project')
    
    png(width=1000, height=500)
    print(p)
    dev.off() 
    ggsave(paste0(flag,'_Pyrome_',PYROMEIN,'_meanbyday_ALLSRCES.png'), p, width = 9, height = 9)
    
    # Create output directory if required
    outputDIR <- file.path(paste0(ROOT_DATA_DIR,'/',OUTPUT_DIR,'/Plots/',outpdir,'/MaxmAllSRCEs'))
    if (!dir.exists(outputDIR)) {dir.create(outputDIR,recursive = TRUE)}
    setwd(outputDIR)
    
    # Plot ggplot - MAX per day
    legend_title <- 'Source Type'
    p <- cnmd.dt.extd.stats %>%
      ggplot( aes(x=DAYOFYR, y=SRCEmax, group=SRCE, fill=SRCE)) +
      geom_line() +
      scale_fill_viridis(discrete = TRUE) +
      theme(legend.position="none") +
      ggtitle( paste0(flag,' Pyrome ',PYROMEIN,' - FFSIM FRISK file inputs ERC comparisons')) +
      theme_ipsum() +
      theme(
        legend.position="none",
        panel.spacing = unit(0, "lines"),
        strip.text.x = element_text(size = 8),
        plot.title = element_text(size=13)
      ) +
      facet_wrap(~SRCE, scale="free_y")
    
    png(width=1000, height=500)
    print(p)
    dev.off() 
    ggsave(paste0(flag,'_Pyrome_',PYROMEIN,'_maxbyday_ALLSRCES.png'), p, width = 9, height = 9)
    
    # Create output directory if required
    outputDIR <- file.path(paste0(ROOT_DATA_DIR,'/',OUTPUT_DIR,'/Plots/',outpdir,'/Maxm'))
    if (!dir.exists(outputDIR)) {dir.create(outputDIR,recursive = TRUE)}
    setwd(outputDIR)
    
    # Plot ggplot - MAX per day
    legend_title <- 'Source Type'
    p <- ggplot() + geom_line(data=cnmd.dt.extd.stats, aes(x=factor(DAYOFYR), y=SRCEmax, group = factor(SRCE)
                                                           , colour = factor(SRCE)), size=1) + 
      theme(legend.position = c(0.9, 0.8)) + 
      scale_color_discrete(name = legend_title) +
      scale_x_discrete(labels=labelsin) + 
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 8)) +
      scale_y_continuous(breaks = pretty(cnmd.dt.extd.stats$SRCEmax, n = 10)) +
      geom_hline(yintercept = perc80RISQ, colour = 'Red') + 
      geom_hline(yintercept = perc80USFS, colour = 'Turquoise')  +    
      geom_hline(yintercept = perc90RISQ, colour = 'Red',linetype='dotted') + 
      geom_hline(yintercept = perc90USFS, colour = 'Turquoise',linetype='dotted')  + 
      geom_hline(yintercept = perc97RISQ, colour = 'Red',linetype='dashed') + 
      geom_hline(yintercept = perc97USFS, colour = 'Turquoise',linetype='dashed')  +         
      labs(title = paste0(flag,' Pyrome ',PYROMEIN,' - FFSIM FRISK file inputs comparison'),
           subtitle = ('Maximum ERC by Day of Year'),
           x = 'Day of Year',
           y = 'ERC') + labs(caption = 'USFS/risQ Climate Conditioning project')
    
    png(width=1000, height=500)
    print(p)
    dev.off() 
    ggsave(paste0(flag,'_Pyrome_',PYROMEIN,'_maxbyday_ALLSRCES.png'), p, width = 9, height = 9)
  } # Select pyromes
} # All pyromes   

# Plot
ggplot() +
  # plot all simulations
  geom_line(data = ercwthrdat, aes(x = DATE, y = value, color = variable  , group=variable  ), alpha = 1, size = 0.65) +
  labs(x="Date",y=expression('Precipitation Amount (inches)')) +
  theme(text = element_text(size=10))

ercwthrdat %>%
  ggplot( aes(x=DATE, y=value, group=variable, fill=variable)) +
  geom_area() +
  scale_fill_viridis(discrete = TRUE) +
  theme(legend.position="none") +
  ggtitle("Popularity of American names in the previous 30 years") +
  theme_ipsum() +
  theme(
    legend.position="none",
    panel.spacing = unit(0, "lines"),
    strip.text.x = element_text(size = 8),
    plot.title = element_text(size=13)
  ) +
  facet_wrap(~variable, scale="free_y")

setDF(rndm.dirs.dt.pyr)
wrsepyr <-   windRose(rndm.dirs.dt.pyr, ws = "WSDMY", wd = "WDDMY", ws2 = NA, wd2 = NA, 
                      ws.int = 5, angle = 45, type = "MONTH", bias.corr = TRUE, cols
                      = "default", grid.line = 10, width = 1, seg = 2, auto.text 
                      = TRUE, breaks = 5, offset = 10, normalise = FALSE, max.freq = 
                        NULL, paddle = TRUE, key.header = NULL, key.footer = "(m/s)", 
                      key.position = "bottom", key = TRUE, dig.lab = 5, statistic = 
                        "prop.count", pollutant = NULL, annotate = TRUE, angle.scale = 
                        315, border = T,key.columns = 1,pch=seq(8,8),cex=2,
                      par.settings=list(fontsize=list(text=8)))

##################################################################################################################
## Section: Define miscellaneous functions
##################################################################################################################

# Join data to DT of consecutive days covering tim eperiod of data
Merged.DTs <- Reduce(function(x,y) merge(x,y,all=TRUE) , filesappend)

# Remove entries in station data where all variables are NA  
drop_rows_all_na <- function(x, pct=1) x[!rowSums(is.na(x)) >= ncol(x)*pct,]

#Returns all items in a list that are not contained in toMatch
#toMatch can be a single item or a list of items
exclude <- function (theList, toMatch){
  return(setdiff(theList,include(theList,toMatch)))
}

#Returns all items in a list that ARE contained in toMatch
#toMatch can be a single item or a list of items
include <- function (theList, toMatch){
  matches <- unique (grep(paste(toMatch,collapse="|"), 
                          theList, value=TRUE))
  return(matches)
}

# Convert data.table classes 
#dt <- data.table(i=1:3,f=3:1)
#set_colclass(dt, c(i="numeric",f="numeric" ))
#class(dt$i)
#sapply(dt, class)
".." <- function (x) 
{
  stopifnot(inherits(x, "character"))
  stopifnot(length(x) == 1)
  get(x, parent.frame(4))
}

set_colclass <- function(x, class){
  stopifnot(all(class %in% c("integer", "numeric", "double","factor","character")))
  for(i in intersect(names(class), names(x))){
    f <- get(paste0("as.", class[i]))
    x[, (..("i")):=..("f")(get(..("i")))]
  }
  invisible(x)
}

# Test if year is leap or not
is.leapyear <- function(year){
  return(((year %% 4 == 0) & (year %% 100 != 0)) | (year %% 400 == 0))
}

# Test sequence of numbers for consecutive differences of 1, can be changed
seqle <- function(x,incr=1) { 
  if(!is.numeric(x)) x <- as.numeric(x) 
  n <- length(x)  
  #y <- x[-1L] != x[-n] + incr 
  y <- abs(x[-1L] - x[-n] - incr) > .Machine$double.eps ^ 0.5
  i <- c(which(y|is.na(y)),n) 
  list(lengths = diff(c(0L,i)),
       values = x[head(c(0L,i)+1L,-1L)]) 
} 

##################################################################################################################
## Section: Book keeping - Clean memory close file connections
##################################################################################################################

# CLEAN MEMORY
rm(list = ls(all.names = TRUE))
raster::removeTmpFiles(h = 0)
flush.console()

##################################################################################################################
##                                                                                                              ##
##            Program end section to Process weather inputs to carry out trend analysis                         ##
##                                                                                                              ##
##################################################################################################################